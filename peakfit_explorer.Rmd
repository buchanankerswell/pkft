---
title: "Peakfit Explorer"
author: "Buchanan Kerswell"
date: "4/17/2020"
output: html_document
runtime: shiny
---
<style type="text/css">
.main-container {
  max-width: 1280px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(IsoplotR)
```
The purpose of this interactive document is to explore, reduce, visualize, and plot any continuous dataset where each measurement has a corresponding 1$\sigma$ uncertainty. The distribution of the data does not need to be known _a priori_, rather this tool allows for analysis of the distribution and careful (de)selection of outliers.

---

### Instructions

A random dataset is generated automatically, shown in the columns (left panel). The spreadsheet is interactive, so you can remove rows (omitting outliers), or copy/paste your own data. The spreadsheet automatically adds rows if your dataset is more than 15 points.

There are inputs for adjusting the scale, resolution (size of $\Delta~x~axis$ intervals for calculating density), and range of the probability distribution functions (PDFs). Additionally, there are inputs for selecting the number of peaks and for displaying statistics.

---

### Peak fitting

The peak fitting is achieved as follows:

#### Bounding PDF (black curve)
1. A normally-spaced grid is calculated spanning the entire range of the dataset Â± the selected $\sigma$ range
2. Normally-distributed PDFs are calculated for each $\Delta~x~axis$ interval (resolution)
3. The PDFs are summed and normalized, such that the integral is unity

Here is an example of how this works:
```{r, warning=FALSE}
# define function
sum_pdf <- function(measurement,
# measured variable
measurementSds,
# 1 standard deviations
resolution = 0.001,
# resolution of the grid
sigma_range = 5) {
# how many sigma in each direction do you want to go

# evaluate the summed PDF on a grid sigma_range above and below the lowest and highest measured values
# at a resolution of resolution of interest
grid <- seq(
min(measurement - measurementSds * sigma_range),
max(measurement + measurementSds * sigma_range),
by = resolution
)

temp_storage <-
matrix(ncol = length(measurement), nrow = length(grid))
for (i in 1:length(measurement)) {
temp_storage[, i] <-
dnorm(x = grid, mean = measurement[i], sd = measurementSds[i])
}
# add all the PDF's together and make sure they integrate to 1
density  = apply(X = temp_storage, MARGIN = 1, sum) * resolution / length(measurement)
# return the evaluation grid and the densities
return(data.frame(measurement = grid, measurementSds = density))
}

# make up some measurements (ages in this case) and uncertanties for testing
ages <- c(20.13, 20.24, 20.17, 20.09, 20.30)
ageSds <- c(0.05, 0.052, 0.043, 0.037, 0.04)

df <- sum_pdf(measurement = ages, measurementSds = ageSds)

# plot the results
plot(
x = df$measurement,
y = df$measurementSds,
type = 'l',
lwd = 3,
xlab = 'Age',
ylab = 'Density'
)
```

#### Parsed PDFs (pink curves)
1. The `peakfit` function is used to determine the peak mean locations and their standard errors

```{r, eval=FALSE}
install.packages('IsoplotR')
```
2. The R base `dnorm` function is then called to calculate the pink curves

Another example of how this works:
```{r, warning=FALSE}
# Generate random dataset
data <-
data.frame(measurement = runif(21, min = 0, max = 3),
               sde = runif(21, min = 0.1, max = 1))

# Find peaks using IsoplotR peakfit function
peaks <-
peakfit(
data,
k = 3,
sigdig = 2,
log = FALSE,
alpha = 0.05
)
return(peaks)
# Draw normal distributions corresponding to peak positions

# Define a function for drawing multiple dnorm curves
ind_pdf <-
function(positions,
sds,
sigma_range,
resolution,
scaling_factor) {
positions <- positions[!is.nan(positions)]
sds <- sds[!is.nan(sds)]
grids <- lapply(
seq_along(positions),
FUN = function(i) {
vect <- seq(positions[i] - sds[i] * sigma_range,
positions[i] + sds[i] * sigma_range,
by = resolution)
}
)
pdfs <- lapply(
seq_along(positions),
FUN = function(i) {
dnorm(x = grids[[i]],
mean = positions[i],
sd = sds[i])
}
)
dfs <- lapply(
seq_along(positions),
FUN = function(i) {
df <- data.frame('grid' = grids[[i]], 'pdf' = pdfs[[i]])
}
)
return(list('grids' = grids, 'pdfs' = pdfs))
}
# Draw curves
indpdf <-
ind_pdf(peaks$peaks[1,],
peaks$peaks[2,],
sigma_range = 5,
resolution = 0.01)
# plot the results
p <- ggplot(data = data) + geom_histogram(aes(x = data$measurement))
pindpdf <-
lapply(
seq_along(indpdf$grids),
FUN = function(i) {
geom_line(
data = data.frame('grid' = indpdf$grids[[i]],
'pdf' = indpdf$pdfs[[i]]),
aes(x = grid, y = pdf),
color = 'deeppink4',
size = 1,
alpha = 0.5
)
}
)
return(p + pindpdf)
```

---
Note: brush a window and double click to zoom. Double click in a blank area to unzoom.
```{r tabsets, echo=FALSE}
shinyAppFile('app.R', options = list(width = 1200, height = 720))
```




